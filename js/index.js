// Generated by CoffeeScript 1.9.1
(function() {
  var $, C, Lite, Tap, ajax, camelize, class2type, coords, cssNumber, dasherize, encode, eventUtil, handlers, isArray, jsonp, maybeAddPx, type;

  Lite = {};

  $ = this.$ = function(selector) {
    selector = selector.trim();
    return Lite.C($.query(selector));
  };

  Lite.C = function(dom) {
    return new C(dom);
  };

  C = function(dom) {
    var i, len;
    len = dom ? dom.length : 0;
    for (i in dom) {
      this[i] = dom[i];
    }
    this.length = len;
    return this;
  };

  class2type = {};

  cssNumber = {
    'column-count': 1,
    'columns': 1,
    'font-weight': 1,
    'line-height': 1,
    'opacity': 1,
    'z-index': 1,
    'zoom': 1
  };

  isArray = Array.isArray;

  "Boolean Number String Function Array Date RegExp Object Error".split(" ").forEach(function(name) {
    return class2type["[object " + name + "]"] = name.toLowerCase();
  });

  camelize = function(str) {
    return str.replace(/-+(.)?/g, function(match, chr) {
      if (chr) {
        return chr.toUpperCase();
      } else {
        return '';
      }
    });
  };

  dasherize = function(str) {
    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
  };

  encode = function(str) {
    return encodeURIComponent(str);
  };

  type = function(obj) {
    if (obj === null) {
      return String(obj);
    } else {
      return class2type[{}.toString.call(obj)] || "object";
    }
  };

  maybeAddPx = function(name, value) {
    if (typeof value === "number" && !cssNumber[dasherize(name)]) {
      return value + "px";
    } else {
      return value;
    }
  };

  $.ready = function(callback) {
    if (/complete|loaded|interactive/.test(document.readyState) && document.body) {
      callback($);
    } else {
      document.addEventListener('DOMContentLoaded', function() {
        return callback($);
      }, false);
    }
    return this;
  };

  $.each = function(elements, callback) {
    var i, j, key, l, len1, ref;
    if ($.isArraylike(elements)) {
      for (i = j = 0, ref = elements.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (callback.call(elements[i], elements[i], i) === false) {
          return elements;
        }
      }
    } else {
      for (l = 0, len1 = elements.length; l < len1; l++) {
        key = elements[l];
        if (callback.call(elements[key], elements[key], key) === false) {
          return elements;
        }
      }
    }
    return elements;
  };

  $.isArraylike = function(obj) {
    return typeof obj.length === 'number';
  };

  $.query = function(selector) {
    var found, isSimple, maybeClass, maybeID, nameOnly, result, simpleSelectorRE, slice;
    slice = Array.prototype.slice;
    simpleSelectorRE = /^[\w-]*$/;
    result = null;
    found = [];
    maybeID = selector[0] === '#';
    maybeClass = !maybeID && selector[0] === '.';
    nameOnly = maybeID || maybeClass ? selector.slice(1) : selector;
    isSimple = simpleSelectorRE.test(nameOnly);
    if (document.getElementById && isSimple && maybeID) {
      if (found = document.getElementById(nameOnly)) {
        return result = [found];
      } else {
        return [];
      }
    } else {
      if (isSimple && !maybeID && document.getElementsByClassName) {
        if (maybeClass) {
          result = document.getElementsByClassName(nameOnly);
        } else {
          result = document.getElementsByTagName(selector);
        }
      } else {
        result = document.querySelectorAll(selector);
      }
      return result = slice.call(result);
    }
  };

  jsonp = (function() {
    var config, counter, load, setDefaults, window;
    counter = 0;
    window = this;
    config = {};
    load = function(url, pfnError) {
      var done, errorHandler, head, script;
      script = document.createElement('script');
      done = false;
      script.src = url;
      script.async = true;
      errorHandler = pfnError || config.error;
      if (typeof errorHandler === 'function') {
        script.onerror = function(ex) {
          return errorHandler({
            url: url,
            event: ex
          });
        };
      }
      script.onload = script.onreadystatechange = function() {
        if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
          done = true;
          script.onload = script.onreadystatechange = null;
          if (script && script.parentNode) {
            return script.parentNode.removeChild(script);
          }
        }
      };
      if (!head) {
        head = document.getElementsByTagName('head')[0];
      }
      return head.appendChild(script);
    };
    jsonp = function(url, params, callback, callbackName) {
      var key, query, uniqueName;
      query = (url || '').indexOf('?') === -1 ? '?' : '&';
      callbackName = callbackName || config['callbackName'] || 'callback';
      uniqueName = callbackName + "_" + (++counter);
      params = params || {};
      for (key in params) {
        if (params.hasOwnProperty(key)) {
          query += encode(key) + "=" + encode(params[key]) + "&";
        }
      }
      window[uniqueName] = function(data) {
        var e;
        callback(data);
        try {
          delete window[uniqueName];
        } catch (_error) {
          e = _error;
        }
        return window[uniqueName] = null;
      };
      load(url + query + callbackName + '=' + uniqueName);
      return uniqueName;
    };
    setDefaults = function(obj) {
      return config = obj;
    };
    return {
      get: jsonp,
      init: setDefaults
    };
  })();

  $.ajaxSettings = {
    type: 'GET',
    success: function() {},
    error: function() {},
    xhr: function() {
      return new window.XMLHttpRequest();
    },
    headers: {},
    accepts: {
      json: 'application/json',
      html: 'text/html',
      text: 'text/plain'
    },
    timeout: 0
  };

  ajax = function(settings, success, error) {
    var abortTimeout, appendQuery, dataType, k, key, ref, v, xhr;
    abortTimeout = null;
    dataType = settings.dataType;
    appendQuery = function(url, params) {
      var key, query;
      query = (url || '').indexOf('?') === -1 ? '?' : '&';
      if (params === '') {
        return url;
      }
      for (key in params) {
        if (params.hasOwnProperty(key)) {
          query += encode(key) + "=" + encode(params[key]) + "&";
        }
      }
      return (url + query).replace(/[&?]{1,2}/, '?').slice(0, this.length - 1);
    };
    for (key in $.ajaxSettings) {
      if (settings[key] === void 0) {
        settings[key] = $.ajaxSettings[key];
      }
    }
    xhr = settings.xhr();
    if (settings['type'].toUpperCase() === 'GET') {
      settings.url = appendQuery(settings.url, settings.data);
    }
    xhr.onreadystatechange = function() {
      var e, result, rsError;
      if (xhr.readyState === 4) {
        xhr.onreadystatechange = function() {};
        clearTimeout(abortTimeout);
        result;
        rsError = false;
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304 || (xhr.status === 0 && location.protocol === 'file:')) {
          dataType = dataType || xhr.getResponseHeader('content-type');
          result = xhr.responseText;
          try {
            if (dataType === 'application/json') {
              result = /^\s*$/.test(result) ? null : JSON.parse(result);
            }
          } catch (_error) {
            e = _error;
            rsError = e;
          }
          if (rsError) {
            return error(rsError, xhr.status, xhr);
          } else {
            return success(result, xhr.status, xhr);
          }
        } else {
          return error(xhr.statusText || null, xhr.status, xhr);
        }
      }
    };
    xhr.open(settings.type, settings.url, true);
    ref = settings.headers;
    for (k in ref) {
      v = ref[k];
      xhr.setRequestHeader(k, v);
    }
    if (settings.timeout > 0) {
      abortTimeout = setTimeout(function() {
        xhr.onreadystatechange = function() {};
        return xhr.abort();
      }, settings.timeout);
    }
    xhr.send(settings.data ? settings.data : null);
    return xhr;
  };

  Tap = {};

  coords = {};

  eventUtil = {
    attachEvent: function(element, eventName, callback) {
      return element.addEventListener(eventName, callback, false);
    },
    fireFakeEvent: function(e, eventName) {
      if (document.createEvent) {
        return e.target.dispatchEvent(eventUtil.createEvent(eventName));
      }
    },
    createEvent: function(name) {
      var event;
      if (document.createEvent) {
        event = window.document.createEvent('HTMLEvents');
        event.initEvent(name, true, true);
        event.eventName = name;
        return event;
      }
    },
    getRealEvent: function(e) {
      if (e.originalEvent && e.originalEvent.touches && e.originalEvent.touches.length) {
        return e.originalEvent.touches[0];
      } else {
        if (e.touches && e.touches.length) {
          return e.touches[0];
        }
        return e;
      }
    }
  };

  Tap.options = {
    eventName: 'tap',
    fingerMaxOffset: 11
  };

  handlers = {
    start: function(e) {
      e = eventUtil.getRealEvent(e);
      coords.start = [e.pageX, e.pageY];
      return coords.offset = [0, 0];
    },
    move: function(e) {
      if (!coords['start'] && !coords['move']) {
        return false;
      }
      e = eventUtil.getRealEvent(e);
      coords.move = [e.pageX, e.pageY];
      return coords.offset = [Math.abs(coords.move[0] - coords.start[0]), Math.abs(coords.move[1] - coords.start[1])];
    },
    end: function(e) {
      e = eventUtil.getRealEvent(e);
      if (coords.offset[0] < Tap.options.fingerMaxOffset && coords.offset[1] < Tap.options.fingerMaxOffset && !eventUtil.fireFakeEvent(e, Tap.options.eventName)) {
        e.preventDefault();
      }
      return coords = {};
    },
    click: function(e) {
      if (!eventUtil.fireFakeEvent(e, Tap.options.eventName)) {
        return e.preventDefault();
      }
    }
  };

  $.ready(function() {
    var el;
    el = document.documentElement;
    eventUtil.attachEvent(el, 'touchstart', handlers['start']);
    eventUtil.attachEvent(el, 'touchmove', handlers['move']);
    eventUtil.attachEvent(el, 'touchend', handlers['end']);
    return eventUtil.attachEvent(el, 'click', handlers['click']);
  });

  $.ajax = ajax;

  $.jsonp = jsonp;

  $.fn = {
    author: 'bq',
    length: 0,
    forEach: [].forEach,
    reduce: [].reduce,
    push: [].push,
    sort: [].sort,
    splice: [].splice,
    indexOf: [].indexOf,
    each: function(callback) {
      [].every.call(this, function(el, idx) {
        return callback.call(el, el, idx) !== false;
      });
      return this;
    },
    addClass: function(name) {
      if (!name) {
        return this;
      }
      return this.each(function(el, index) {
        return el.classList.add(name);
      });
    },
    removeClass: function(name) {
      if (!name) {
        return this;
      }
      return this.each(function(el, index) {
        return el.classList.remove(name);
      });
    },
    hasClass: function(name) {
      if (!name) {
        return this;
      }
      return this.each(function(el, index) {
        return el.classList.contains(name);
      });
    },
    toggleClass: function(name) {
      if (!name) {
        return this;
      }
      return this.each(function(el, index) {
        if (el.classList.contains(name)) {
          return el.classList.remove(name);
        } else {
          return el.classList.add(name);
        }
      });
    },
    css: function(property, value) {
      var computedStyle, css, element, key, props;
      if (arguments.length < 2) {
        element = this[0];
        if (!element) {
          return;
        }
        computedStyle = getComputedStyle(element, '');
        if (typeof property === 'string') {
          return element.style[camelize(property)] || computedStyle.getPropertyValue(property);
        } else {
          if (isArray(property)) {
            props = {};
            $.each(property, function(prop) {
              return props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop);
            });
            props;
          }
        }
      }
      css = '';
      if (type(property) === 'string') {
        if (!value && value !== 0) {
          this.each(function() {
            return this.style.removeProperty(dasherize(property));
          });
        } else {
          css = dasherize(property) + ":" + maybeAddPx(property, value);
        }
      } else {
        for (key in property) {
          value = property[key];
          if (!value && value !== 0) {
            this.each(function() {
              return this.style.removeProperty(dasherize(key));
            });
          } else {
            css += dasherize(key) + ':' + maybeAddPx(key, value) + ';';
          }
        }
      }
      return this.each(function() {
        return this.style.cssText += ';' + css;
      });
    }
  };

  $.fn.on = function(event, callback) {
    return this.each(function(el) {
      return el.addEventListener(event, callback);
    });
  };

  Lite.C.prototype = C.prototype = $.fn;

  $.Lite = Lite;

}).call(this);

//# sourceMappingURL=index.js.map
